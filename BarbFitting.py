import cadquery as cq
from typing import Generator
import OCP

import math

#Barbed fitting
class BarbFitting:
    #the basic cone/cylinder that serves as the body of the fitting
    body = None
    
    def __init__ (self, maj_dia: float,length: float, barb: Generator, 
                  tip: [None, float]= None, taper: float=0, parent=None  ):
        if taper == 0:
            body = cq.Solid.makeCylinder(maj_dia,length)
        else:
            body = cq.Solid.makeCone(maj_dia,maj_dia*(1-taper),length)
        
        self.parent = cq.Workplane() if parent is None else parent
        self.parent = self.parent.add(body)
b = BarbFitting(2,10,range(0),taper = .25)
#SHOW = b.parent

# "Calculables" idea:
# All the geometric properties that a object can generate on demand are defined in a dict
# of functions (sympy functions????) 
    

class thread:
    direction_vect = cq.Vector(1,0,0).wrapped
    invalidthreadexception = lambda self,taper,pitch: AttributeError("Invalid thread generated by {self.__class__.__name__} from args taper {taper} and pitch {pitch}"
                                                       .format(**locals()))
    def __init__(self):
        raise NotImplemented
    # Complexities:
    # -length of thread profile shifts with taper
    # -Profile is perpendicular to axis, this means that it effectively narrows as helix angle increases
    # - This likely leads to extreme distortion with multi-start threads at low pitch.
    # - tapered thread mesh generation: polygons must be added in a smart way as to prevent loss
    #   of definition as tapered screw increases in diameter
    
    # Optimizations/checks:
    # Confirm that a calculated thread line is of the length apropriate for a given pitch value
    # Confirm that, on a tapered screw, the specified taper is followed accordingly.
    # Confirm that pitch diameter is apropriately between major and minor diameter
    # Confirm that 
    
    
    # Calculations/properties/convinence:
    # - Helix angle?
    # - Major cone (surface)
    # - Minor cone (surface)
    # - Pitch cone (surface)
    # - Thread angle???
    def check_thread(self,thread: cq.Wire) -> bool:
        # Todo
        return True
    
    def genline(self,taper,pitch)-> cq.Wire:
        raise NotImplemented
    
    def draw (self,taper,pitch):
        l = self.genline(taper,pitch)
        if self.check_thread(l):
            return l
        else:
            raise self.invalidthreadexception(taper,pitch)


class simpletriangle (thread):
    def __init__(self, angle):
        self.angle = angle
    
    def genline(self,taper,pitch) -> cq.Wire:
        y_val = lambda ang, dist :dist/2*math.tan(math.radians(ang))
        
        p1 = cq.Vector(0,0,0)
        p2 = cq.Vector(pitch/2,y_val(self.angle,pitch/2),0)
        p3 = cq.Vector(pitch,0,0)
        
        l1 = cq.Edge.makeLine(p1,p2)
        l2 = cq.Edge.makeLine(p2,p3)
        
        return cq.Wire.assembleEdges([l1,l2])

def build_disc(thread_model:thread,radius:int,pitch:int,taper = 0):
    # Works now! So long as the normal remains as 0,0,1 and NOTHING ELSE
    if taper:
        raise ValueError("Taper is not yet supported")

    norm = cq.Vector(0,0,1).normalized()
    perp_axis = cq.Vector(1,0,0).normalized().wrapped
    perpendicularize = OCP.gp.gp_Quaternion(perp_axis,-math.pi/2)
    
    #relevant coordinate system
    

    # Generate a transformation from where the thread object is defined
    # (which is always the plane along the x axis, towards positive Y)
    # To the provided normal axis.
    rot = OCP.gp.gp_Quaternion(thread.direction_vect,norm.wrapped)
    
    # Make the thread profile perpendicular to the tangent axis.
    # Hard-coded for screw extending upwards on z axis.
    # At some point, change how norm, and perpendicularize work to make this useful.
    rot = rot * perpendicularize
    
    # Generates the propper coordinate system for the thread
    # takes a quaterion and a vector.
    coord = OCP.gp.gp_Trsf()
    coord.SetTransformation(rot,cq.Vector(radius,0,0).wrapped)

    
    # TODO:
    # How do I get the thread profile oriented along the axis?
    # I have a quarterion, how do I apply it to the cq.Wire object or the OCP.TopoDS.TopoDS_Wire
    # Leads:
    # The TopoDS_Shape is the parent for DS_Wire.
    # - See Orientation	(	const TopAbs_Orientation 	Orient	)
    # - See Move	(	const TopLoc_Location & 	position	)
    # - See Location	(	const TopLoc_Location & 	Loc	)
    
    p = thread_model.draw(taper,pitch)
    p.wrapped.Location(OCP.TopLoc.TopLoc_Location(coord))
    d = cq.Wire.makeCircle(radius,cq.Vector(0,0,0),norm)
    
    pipe = OCP.BRepOffsetAPI.BRepOffsetAPI_MakePipeShell(d.wrapped)
    pipe.Add(p.wrapped)
    #log("READY" if pipe.IsReady() else "NOT READY")
    pipe.Build()
    res = cq.Shape.cast(pipe.Shape())
    #log("SDRAWTYPE:"+str(type(res)))
    return res

def red_Cylinder():
    c = cq.Solid.makeCylinder(1,1)
    c.wrapped = OCP.AIS.AIS_TexturedShape(c.wrapped)
    return c 

def buildHelix (thread_model:thread,taper,radius,pitch,height):
    if taper:
        raise ValueError("Taper is not yet supported")
    
    he = cq.Wire.makeHelix(pitch,height,radius)
    th = thread_model.draw(taper,pitch)
    return he
    

s = simpletriangle(60)

#v = cq.Workplane(s.draw(0,1))

# You can use CadQuery to build a path, and perform the sweep
# Then use OCP mesh healing to fix the resulting surface!
rotaxis = OCP.gp.gp_Ax1(OCP.gp.gp_Pnt(0,0,0),OCP.gp.gp_Dir(1,0,0))
#occgen = cq.Shape.cast(OCP.BRepPrimAPI.BRepPrimAPI_MakeRevol(wire,rotaxis).Shape())
loc = cq.Location(cq.Vector(1,1,1))

#he = buildHelix(s,0,5,1,20)

d = cq.Workplane(build_disc(s,5,1,0))
show_object(red_Cylinder())